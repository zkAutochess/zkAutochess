// SPDX-License-Identifier: Apache-2.0.
//---------------------------------------------------------------------------//
// Copyright (c) 2023 Generated by ZKLLVM-transpiler
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//---------------------------------------------------------------------------//
pragma solidity >=0.8.4;

import "../../cryptography/transcript.sol";
import "../../interfaces/modular_commitment.sol";
// Move away unused structures from types.sol
import "../../types.sol";
import "../../basic_marshalling.sol";
import "../../containers/merkle_verifier.sol";
import "../../algebra/polynomial.sol";
import "hardhat/console.sol";

library modular_commitment_scheme_template {
    uint256 constant modulus = 28948022309329048855892746252171976963363056481941560715954676764349967630337;
    uint64 constant batches_num = 4;
    uint256 constant r = 15;
    uint256 constant lambda = 9;
    uint256 constant D0_size = 65536;
    uint256 constant max_degree = 65535;
    uint256 constant D0_omega = 10988054172925167713694812535142550583545019937971378974362050426778203868934;
    uint256 constant unique_points = 4;
    uint256 constant permutation_point = 2;
    uint256 constant quotient_point = 0;
    uint256 constant lookup_point = 140727634771680;
    bytes constant points_ids =
        hex"01010101010101010101010101010101010101010101010101010101010101010101010101010101010103030101010101010101010101010101010101010101010101010101010101010101010101010101010100000000000000000000000000000000";
    uint256 constant omega = 10988054172925167713694812535142550583545019937971378974362050426778203868934;
    uint256 constant _etha = 1890666600192650576104892855328225977440480664960926152787778175883206235408;

    struct commitment_state {
        bytes leaf_data;
        uint256 roots_offset;
        uint256 initial_data_offset;
        uint256 initial_proof_offset;
        uint256 round_proof_offset;
        uint256 round_data_offset;
        uint256[r] alphas;
        uint64[batches_num] batch_sizes;
        uint64 poly_num;
        uint256 points_num;
        uint256 theta;
        uint256 x_index;
        uint256 x;
        uint256 max_batch;
        uint256 domain_size;
        uint256[] final_polynomial;
        uint256 leaf_length;
        uint256[][unique_points] denominators;
        uint256[unique_points] factors;
        uint256[][unique_points] combined_U;
        uint256[][unique_points] unique_eval_points;
        uint256[2] y;
        uint256 j;
        uint256 offset;
    }

    function calculate_2points_interpolation(uint256[] memory xi, uint256[2] memory z)
        internal
        pure
        returns (uint256[2] memory U)
    {
        //        require( xi.length == 2 );
        unchecked {
            U[0] = addmod(mulmod(z[0], xi[1], modulus), modulus - mulmod(z[1], xi[0], modulus), modulus);
            U[1] = addmod(z[1], modulus - z[0], modulus);
        }
    }

    //  coeffs for zs on each degree can be precomputed if necessary
    function calculate_3points_interpolation(uint256[] memory xi, uint256[3] memory z)
        internal
        pure
        returns (uint256[3] memory U)
    {
        //        require( xi.length == 3 );
        unchecked {
            z[0] = mulmod(z[0], addmod(xi[1], modulus - xi[2], modulus), modulus);
            z[1] = mulmod(z[1], addmod(xi[2], modulus - xi[0], modulus), modulus);
            z[2] = mulmod(z[2], addmod(xi[0], modulus - xi[1], modulus), modulus);

            U[0] = mulmod(z[0], mulmod(xi[1], xi[2], modulus), modulus);
            U[0] = addmod(U[0], mulmod(z[1], mulmod(xi[0], xi[2], modulus), modulus), modulus);
            U[0] = addmod(U[0], mulmod(z[2], mulmod(xi[0], xi[1], modulus), modulus), modulus);

            U[1] = modulus - mulmod(z[0], addmod(xi[1], xi[2], modulus), modulus);
            U[1] = addmod(U[1], modulus - mulmod(z[1], addmod(xi[0], xi[2], modulus), modulus), modulus);
            U[1] = addmod(U[1], modulus - mulmod(z[2], addmod(xi[0], xi[1], modulus), modulus), modulus);

            U[2] = addmod(z[0], addmod(z[1], z[2], modulus), modulus);
        }
    }

    function prepare_eval_points(uint256[][unique_points] memory result, uint256 xi) internal view {
        uint256 inversed_omega = field.inverse_static(omega, modulus);
        result[0] = new uint256[](1);
        result[0][0] = xi;
        result[1] = new uint256[](2);
        result[1][0] = xi;
        result[1][1] = _etha;
        result[2] = new uint256[](2);
        result[2][0] = xi;
        result[2][1] = mulmod(xi, omega, modulus);
        result[3] = new uint256[](3);
        result[3][0] = xi;
        result[3][1] = mulmod(xi, omega, modulus);
        result[3][2] = _etha;
    }

    function prepare_U_V(bytes calldata blob, commitment_state memory state, uint256 xi)
        internal
        view
        returns (bool result)
    {
        unchecked {
            result = true;
            uint64 ind = 0;
            prepare_eval_points(state.unique_eval_points, xi);
            // Prepare denominators
            for (ind = 0; ind < state.unique_eval_points.length;) {
                state.denominators[ind] = new uint256[](state.unique_eval_points[ind].length + 1);
                if (state.unique_eval_points[ind].length == 1) {
                    state.factors[ind] = 1;
                    state.denominators[ind][0] = modulus - state.unique_eval_points[ind][0];
                    state.denominators[ind][1] = 1;
                } else if (state.unique_eval_points[ind].length == 2) {
                    // xi1 - xi0
                    state.factors[ind] =
                        addmod(state.unique_eval_points[ind][1], modulus - state.unique_eval_points[ind][0], modulus);
                    state.denominators[ind][2] = 1;

                    state.denominators[ind][1] =
                        modulus - addmod(state.unique_eval_points[ind][0], state.unique_eval_points[ind][1], modulus);

                    state.denominators[ind][0] =
                        mulmod(state.unique_eval_points[ind][0], state.unique_eval_points[ind][1], modulus);
                    state.denominators[ind][0] = mulmod(state.denominators[ind][0], state.factors[ind], modulus);
                    state.denominators[ind][1] = mulmod(state.denominators[ind][1], state.factors[ind], modulus);
                    state.denominators[ind][2] = mulmod(state.denominators[ind][2], state.factors[ind], modulus);
                } else if (state.unique_eval_points[ind].length == 3) {
                    state.factors[ind] = modulus
                        - mulmod(
                            mulmod(
                                addmod(
                                    state.unique_eval_points[ind][0], modulus - state.unique_eval_points[ind][1], modulus
                                ),
                                addmod(
                                    state.unique_eval_points[ind][1], modulus - state.unique_eval_points[ind][2], modulus
                                ),
                                modulus
                            ),
                            addmod(state.unique_eval_points[ind][2], modulus - state.unique_eval_points[ind][0], modulus),
                            modulus
                        );
                    state.denominators[ind][3] = 1;
                    state.denominators[ind][2] = modulus
                        - addmod(
                            state.unique_eval_points[ind][0],
                            addmod(state.unique_eval_points[ind][1], state.unique_eval_points[ind][2], modulus),
                            modulus
                        );
                    state.denominators[ind][1] = addmod(
                        mulmod(state.unique_eval_points[ind][0], state.unique_eval_points[ind][1], modulus),
                        addmod(
                            mulmod(state.unique_eval_points[ind][0], state.unique_eval_points[ind][2], modulus),
                            mulmod(state.unique_eval_points[ind][1], state.unique_eval_points[ind][2], modulus),
                            modulus
                        ),
                        modulus
                    );
                    state.denominators[ind][0] = modulus
                        - mulmod(
                            state.unique_eval_points[ind][0],
                            mulmod(state.unique_eval_points[ind][1], state.unique_eval_points[ind][2], modulus),
                            modulus
                        );
                    state.denominators[ind][0] = mulmod(state.denominators[ind][0], state.factors[ind], modulus);
                    state.denominators[ind][1] = mulmod(state.denominators[ind][1], state.factors[ind], modulus);
                    state.denominators[ind][2] = mulmod(state.denominators[ind][2], state.factors[ind], modulus);
                    state.denominators[ind][3] = mulmod(state.denominators[ind][3], state.factors[ind], modulus);
                } else {
                    console.log("UNPROCESSED number of evaluation points");
                    return false;
                }
                ind++;
            }

            // Prepare combined U
            for (uint256 ind = 0; ind < unique_points;) {
                uint256[] memory point = state.unique_eval_points[ind];
                state.combined_U[ind] = new uint256[](state.unique_eval_points[ind].length);
                uint64 cur = 0;
                uint256 offset = 0x8;
                for (uint256 k = 0; k < batches_num;) {
                    for (uint256 i = 0; i < state.batch_sizes[k];) {
                        uint256 cur_point = 0;
                        if (cur < points_ids.length) cur_point = uint8(points_ids[cur]);
                        else if (k == 2) cur_point = permutation_point;
                        else if (k == 3) cur_point = quotient_point;
                        else if (k == 4) cur_point = lookup_point;
                        else console.log("Wrong index");

                        polynomial.multiply_poly_on_coeff(state.combined_U[ind], state.theta, modulus);
                        if (cur_point == ind) {
                            if (point.length == 1) {
                                state.combined_U[ind][0] = addmod(
                                    state.combined_U[ind][0], basic_marshalling.get_uint256_be(blob, offset), modulus
                                );
                            } else if (point.length == 2) {
                                uint256[2] memory tmp;
                                tmp[0] = basic_marshalling.get_uint256_be(blob, offset);
                                tmp[1] = basic_marshalling.get_uint256_be(blob, offset + 0x20);
                                tmp = calculate_2points_interpolation(point, tmp);
                                state.combined_U[ind][0] = addmod(state.combined_U[ind][0], tmp[0], modulus);
                                state.combined_U[ind][1] = addmod(state.combined_U[ind][1], tmp[1], modulus);
                            } else if (point.length == 3) {
                                uint256[3] memory tmp;
                                tmp[0] = basic_marshalling.get_uint256_be(blob, offset);
                                tmp[1] = basic_marshalling.get_uint256_be(blob, offset + 0x20);
                                tmp[2] = basic_marshalling.get_uint256_be(blob, offset + 0x40);
                                tmp = calculate_3points_interpolation(point, tmp);
                                state.combined_U[ind][0] = addmod(state.combined_U[ind][0], tmp[0], modulus);
                                state.combined_U[ind][1] = addmod(state.combined_U[ind][1], tmp[1], modulus);
                                state.combined_U[ind][2] = addmod(state.combined_U[ind][2], tmp[2], modulus);
                            } else {
                                return false;
                            }
                        }
                        offset += state.unique_eval_points[cur_point].length * 0x20;
                        i++;
                        cur++;
                    }
                    k++;
                }
                ind++;
            }
        }
    }

    function compute_combined_Q(bytes calldata blob, commitment_state memory state)
        internal
        view
        returns (uint256[2] memory y)
    {
        unchecked {
            uint256[2][unique_points] memory values;
            {
                uint256 offset = state.initial_data_offset - state.poly_num * 0x40; // Save initial data offset for future use;
                uint256 cur = 0;
                for (uint256 b = 0; b < batches_num;) {
                    for (uint256 j = 0; j < state.batch_sizes[b];) {
                        uint256 cur_point = 0;
                        if (cur < points_ids.length) cur_point = uint8(points_ids[cur]);
                        else if (b == 2) cur_point = permutation_point;
                        else if (b == 3) cur_point = quotient_point;
                        else if (b == 4) cur_point = lookup_point;
                        else console.log("Wrong index");

                        for (uint256 k = 0; k < unique_points;) {
                            values[k][0] = mulmod(values[k][0], state.theta, modulus);
                            values[k][1] = mulmod(values[k][1], state.theta, modulus);
                            k++;
                        }

                        values[cur_point][0] =
                            addmod(values[cur_point][0], basic_marshalling.get_uint256_be(blob, offset), modulus);
                        values[cur_point][1] =
                            addmod(values[cur_point][1], basic_marshalling.get_uint256_be(blob, offset + 0x20), modulus);
                        offset += 0x40;
                        j++;
                        cur++;
                    }
                    b++;
                }
            }
            for (uint256 p = 0; p < unique_points;) {
                uint256[2] memory tmp = values[p];
                tmp[0] = mulmod(tmp[0], state.factors[p], modulus);
                tmp[1] = mulmod(tmp[1], state.factors[p], modulus);
                uint256 s = state.x;
                tmp[0] = addmod(tmp[0], modulus - polynomial.evaluate(state.combined_U[p], s, modulus), modulus);
                tmp[1] =
                    addmod(tmp[1], modulus - polynomial.evaluate(state.combined_U[p], modulus - s, modulus), modulus);
                tmp[0] = mulmod(
                    tmp[0],
                    field.inverse_static(polynomial.evaluate(state.denominators[p], s, modulus), modulus),
                    modulus
                );
                tmp[1] = mulmod(
                    tmp[1],
                    field.inverse_static(polynomial.evaluate(state.denominators[p], modulus - s, modulus), modulus),
                    modulus
                );
                y[0] = addmod(y[0], tmp[0], modulus);
                y[1] = addmod(y[1], tmp[1], modulus);
                p++;
            }
        }
    }

    function initialize(bytes32 tr_state_before) internal returns (bytes32 tr_state_after) {
        types.transcript_data memory tr_state;
        tr_state.current_challenge = tr_state_before;
        uint256 etha = transcript.get_field_challenge(tr_state, modulus);
        require(etha == _etha, "Wrong etha");
        tr_state_after = tr_state.current_challenge;
    }

    function copy_memory_pair_and_check(
        bytes calldata blob,
        uint256 proof_offset,
        bytes memory leaf,
        uint256[2] memory pair
    ) internal pure returns (bool b) {
        uint256 c = pair[0];
        uint256 d = pair[1];
        assembly {
            mstore(add(leaf, 0x20), c)
            mstore(add(leaf, 0x40), d)
        }
        if (!merkle_verifier.parse_verify_merkle_proof_bytes_be(blob, proof_offset, leaf, 0x40)) {
            return false;
        } else {
            return true;
        }
    }

    function copy_reverted_memory_pair_and_check(
        bytes calldata blob,
        uint256 proof_offset,
        bytes memory leaf,
        uint256[2] memory pair
    ) internal pure returns (bool b) {
        uint256 c = pair[0];
        uint256 d = pair[1];
        assembly {
            mstore(add(leaf, 0x20), d)
            mstore(add(leaf, 0x40), c)
        }
        if (!merkle_verifier.parse_verify_merkle_proof_bytes_be(blob, proof_offset, leaf, 0x40)) {
            return false;
        } else {
            return true;
        }
    }

    function copy_pairs_and_check(
        bytes calldata blob,
        uint256 offset,
        bytes memory leaf,
        uint256 size,
        uint256 proof_offset
    ) internal pure returns (bool b) {
        unchecked {
            uint256 offset2 = 0x20;
            for (uint256 k = 0; k < size;) {
                assembly {
                    mstore(add(leaf, offset2), calldataload(add(blob.offset, offset)))
                    mstore(add(leaf, add(offset2, 0x20)), calldataload(add(blob.offset, add(offset, 0x20))))
                }
                k++;
                offset2 += 0x40;
                offset += 0x40;
            }
            if (!merkle_verifier.parse_verify_merkle_proof_bytes_be(blob, proof_offset, leaf, offset2 - 0x20)) {
                return false;
            } else {
                return true;
            }
        }
    }

    function copy_reverted_pairs_and_check(
        bytes calldata blob,
        uint256 offset,
        bytes memory leaf,
        uint256 size,
        uint256 proof_offset
    ) internal pure returns (bool) {
        unchecked {
            uint256 offset2 = 0x20;
            for (uint256 k = 0; k < size;) {
                assembly {
                    mstore(add(leaf, offset2), calldataload(add(blob.offset, add(offset, 0x20))))
                    mstore(add(leaf, add(offset2, 0x20)), calldataload(add(blob.offset, offset)))
                }
                k++;
                offset2 += 0x40;
                offset += 0x40;
            }
            if (!merkle_verifier.parse_verify_merkle_proof_bytes_be(blob, proof_offset, leaf, offset2 - 0x20)) {
                return false;
            } else {
                return true;
            }
        }
    }

    function colinear_check(uint256 x, uint256[2] memory y, uint256 alpha, uint256 colinear_value)
        internal
        pure
        returns (bool)
    {
        unchecked {
            uint256 tmp;
            tmp = addmod(y[0], y[1], modulus);
            tmp = mulmod(tmp, x, modulus);
            tmp = addmod(tmp, mulmod(alpha, addmod(y[0], modulus - y[1], modulus), modulus), modulus);
            uint256 tmp1 = mulmod(colinear_value, 2, modulus);
            tmp1 = mulmod(tmp1, x, modulus);
            if (tmp != tmp1) {
                console.log("Colinear check failed");
                return false;
            }
            return true;
        }
    }

    function verify_eval(
        bytes calldata blob,
        uint256[5] memory commitments,
        uint256 challenge,
        bytes32 transcript_state
    ) internal view returns (bool) {
        unchecked {
            types.transcript_data memory tr_state;
            tr_state.current_challenge = transcript_state;
            commitment_state memory state;

            {
                uint256 poly_at_eta;
                /* 1 - 2*permutation_size */
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 40); // 0
                if (poly_at_eta != 0x42e1451d2c650c112f2bba1840ae2ad603262859101987d152952e7e8b49510) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x68); // 0x1
                if (poly_at_eta != 0x14e665991ddf93c55ebdaa2794366d62e0fbec9bd507fa7169ce9e878b86e950) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xa8); // 0x2
                if (poly_at_eta != 0x287ffbfd955de2dad9b452c5e51022ee42a5060f1fdaeb1b77dbe7b8b9a28e8f) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xe8); // 0x3
                if (poly_at_eta != 0xa7febf3ead56e4640859ddd7950aea6e6655357835fac368bc3f3d4a02cc8c8) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x128); // 0x4
                if (poly_at_eta != 0x347f9bc3962b275f429c15535e9369427ffaa0b590de5d10bad3c32720dfebe8) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x168); // 0x5
                if (poly_at_eta != 0x67e0ad1eed7c4dc4d0c6aa0d8e10e4bf6cabf9baf23ece5416e0c0fa45f9b84) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1a8); // 0x6
                if (poly_at_eta != 0x20763619aa36d84d813e15243c65477bd1f5be0a6bb3a07a47263c4e35de0994) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1e8); // 0x7
                if (poly_at_eta != 0x224f0e8053123983863669b52dfa656ad53f843c07e8302c3164cbad0d562fe2) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x228); // 0x8
                if (poly_at_eta != 0x2b8b48819f5b1f919f101089e5e3fb15e5b0633414eefea5c49d988742aeef68) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x268); // 0x9
                if (poly_at_eta != 0x19b86a881cc79dd81b5052b17d73e76d159e25104cc40dea0b8c67dd4d6aad05) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x2a8); // 0xa
                if (poly_at_eta != 0x9a14a88fe6153888919d7773438521278987596d3a535b0763a57883156117) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x2e8); // 0xb
                if (poly_at_eta != 0x302674acf7e6a1aaad81355405199a5c5afa4bf2223a0c724f23b5a8f6ae573) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x328); // 0xc
                if (poly_at_eta != 0xf0c04760d781285563860aa4198003cdc6e37bbaab223e3b8bb28c4cd167b3f) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x368); // 0xd
                if (poly_at_eta != 0xb3c164e43585c9aaf19e35347f801302be07dae4c2dba57027a9aeb0170683a) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x3a8); // 0xe
                if (poly_at_eta != 0x382c6f8750b9cf056b8170a067d805f0db6274677ce4a3b30c65069707320922) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x3e8); // 0xf
                if (poly_at_eta != 0x18de2da493a10b1b1987332207381db3bfd1e2154b434e10d9445d3f23fa2da6) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x428); // 0x10
                if (poly_at_eta != 0x3c56e436e22537877fa3ffaa241894829cd2d16e6f038d38a528a14eb3e2e43d) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x468); // 0x11
                if (poly_at_eta != 0x2db275126aba15a57e33fe52b47ae68c8703b33805ddddacd51662d5836e752d) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x4a8); // 0x12
                if (poly_at_eta != 0x247c495c15a26c3b7703f79d866680be3c3eb524016e690d5de85b64912849de) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x4e8); // 0x13
                if (poly_at_eta != 0x366d6ecc6c2c1d295313d613a00083b6e8ac57bbf48e1b0ba32f671cd5c97154) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x528); // 0x14
                if (poly_at_eta != 0x102329fe1cdc91ce9f632e6220029292024352bba192a2cbcb383fdc2cef36a0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x568); // 0x15
                if (poly_at_eta != 0x1eff212aa83202a9e67372807a21fe1a1b699310d4ceaac859913fbae35a967d) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x5a8); // 0x16
                if (poly_at_eta != 0x2918b308ee81dc6146da41def7c086fadfddc6c27be3b8b78921c1cf4bd1f935) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x5e8); // 0x17
                if (poly_at_eta != 0x175a8cd841148481778fd474f51c2a7cc408d33f8e35e164641d29debc3ae71d) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x628); // 0x18
                if (poly_at_eta != 0x3ec68c84da6d74ad7a24875355ff21e401bc10131db75242b4e37e5eec5079a) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x668); // 0x19
                if (poly_at_eta != 0x347f9bc3962b275f429c15535e9369427ffaa0b590de5d10bad3c32720dfebe8) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x6a8); // 0x1a
                if (poly_at_eta != 0x67e0ad1eed7c4dc4d0c6aa0d8e10e4bf6cabf9baf23ece5416e0c0fa45f9b84) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x6e8); // 0x1b
                if (poly_at_eta != 0x20763619aa36d84d813e15243c65477bd1f5be0a6bb3a07a47263c4e35de0994) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x728); // 0x1c
                if (poly_at_eta != 0x224f0e8053123983863669b52dfa656ad53f843c07e8302c3164cbad0d562fe2) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x768); // 0x1d
                if (poly_at_eta != 0x2b8b48819f5b1f919f101089e5e3fb15e5b0633414eefea5c49d988742aeef68) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x7a8); // 0x1e
                if (poly_at_eta != 0x19b86a881cc79dd81b5052b17d73e76d159e25104cc40dea0b8c67dd4d6aad05) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x7e8); // 0x1f
                if (poly_at_eta != 0x9a14a88fe6153888919d7773438521278987596d3a535b0763a57883156117) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x828); // 0x20
                if (poly_at_eta != 0x302674acf7e6a1aaad81355405199a5c5afa4bf2223a0c724f23b5a8f6ae573) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x868); // 0x21
                if (poly_at_eta != 0xf0c04760d781285563860aa4198003cdc6e37bbaab223e3b8bb28c4cd167b3f) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x8a8); // 0x22
                if (poly_at_eta != 0xb3c164e43585c9aaf19e35347f801302be07dae4c2dba57027a9aeb0170683a) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x8e8); // 0x23
                if (poly_at_eta != 0x382c6f8750b9cf056b8170a067d805f0db6274677ce4a3b30c65069707320922) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x928); // 0x24
                if (poly_at_eta != 0x1e6ebcd4a6eaf8e4cee09893f62b9b4ee5983f499f20b3ba59d24041a1b6ee36) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x968); // 0x25
                if (poly_at_eta != 0x3c56e436e22537877fa3ffaa241894829cd2d16e6f038d38a528a14eb3e2e43d) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x9a8); // 0x26
                if (poly_at_eta != 0x3273896761004bf1fd84f4c3c9ce27515024191ac2d2814e10432606abc311ac) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x9e8); // 0x27
                if (poly_at_eta != 0x247c495c15a26c3b7703f79d866680be3c3eb524016e690d5de85b64912849de) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xa28); // 0x28
                if (poly_at_eta != 0x366d6ecc6c2c1d295313d613a00083b6e8ac57bbf48e1b0ba32f671cd5c97154) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xa68); // 0x29
                if (poly_at_eta != 0x102329fe1cdc91ce9f632e6220029292024352bba192a2cbcb383fdc2cef36a0) return false;
                /* 2 - special selectors */
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xac8); // 0x2a
                if (poly_at_eta != 0x3fdb74d82660bef30da5ebd02b7cb50152165c41c6de96444712c41d78f77dfe) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xb28); // 0x2b
                if (poly_at_eta != 0x629df75bdacb6f996ac6fa44de2da9a8c97dd85b494bb4810fd4dbb7bee7016) return false;
                /* 3 - constant columns */
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xb68); // 0x2c
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xba8); // 0x2d
                if (poly_at_eta != 0x3d197f7071d53830ce74a6bbfeb41ad94d31a51de846c79669225172a8f20f1c) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xbe8); // 0x2e
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xc28); // 0x2f
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xc68); // 0x30
                if (poly_at_eta != 0x0) return false;
                /* 4 - selector columns */
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xca8); // 0x31
                if (poly_at_eta != 0x1640ecc317119378cc8cb97676c9c31997de3a3275291d30585a0ed5ec0bf99d) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xce8); // 0x32
                if (poly_at_eta != 0x236d032c0e2a834581937f9f31562fd77292fdc345c2d7646b7a053054175713) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xd28); // 0x33
                if (poly_at_eta != 0x1b9b41c0f4dcacd28d7ca0512bcf1bc454dd4391b3cec8330a3a59064e6bc12f) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xd68); // 0x34
                if (poly_at_eta != 0x275fa4ec642945d81131e63eb2c529e55a5933fdf37a5db26138855366d8313c) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xda8); // 0x35
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xde8); // 0x36
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xe28); // 0x37
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xe68); // 0x38
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xea8); // 0x39
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xee8); // 0x3a
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xf28); // 0x3b
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xf68); // 0x3c
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xfa8); // 0x3d
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xfe8); // 0x3e
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1028); // 0x3f
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1068); // 0x40
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x10a8); // 0x41
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x10e8); // 0x42
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1128); // 0x43
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1168); // 0x44
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x11a8); // 0x45
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x11e8); // 0x46
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1228); // 0x47
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1268); // 0x48
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x12a8); // 0x49
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x12e8); // 0x4a
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1328); // 0x4b
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1368); // 0x4c
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x13a8); // 0x4d
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x13e8); // 0x4e
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1428); // 0x4f
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1468); // 0x50
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x14a8); // 0x51
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x14e8); // 0x52
                if (poly_at_eta != 0x0) return false;
                poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1528); // 0x53
                if (poly_at_eta != 0x0) return false;
            }

            {
                uint256 offset;

                if (challenge != transcript.get_field_challenge(tr_state, modulus)) return false;

                for (uint8 i = 0; i < batches_num;) {
                    transcript.update_transcript_b32(tr_state, bytes32(commitments[i]));
                    i++;
                }
                state.theta = transcript.get_field_challenge(tr_state, modulus);

                state.points_num = basic_marshalling.get_length(blob, 0x0);
                offset = 0x8 + state.points_num * 0x20 + 0x8;
                for (uint8 i = 0; i < batches_num;) {
                    state.batch_sizes[i] = uint64(uint8(blob[offset + 0x1]));
                    if (state.batch_sizes[i] > state.max_batch) state.max_batch = state.batch_sizes[i];
                    state.poly_num += state.batch_sizes[i];
                    i++;
                    offset += 2;
                }

                offset += 0x8;
                offset += state.poly_num;
                state.roots_offset = offset + 0x8;
                offset += 0x8;

                for (uint8 i = 0; i < r;) {
                    transcript.update_transcript_b32(
                        tr_state, bytes32(basic_marshalling.get_uint256_be(blob, offset + 0x8))
                    );
                    state.alphas[i] = transcript.get_field_challenge(tr_state, modulus);
                    i++;
                    offset += 40;
                }

                offset += 0x8 + r;
                state.initial_data_offset = offset + 0x8;
                offset += 0x8 + 0x20 * basic_marshalling.get_length(blob, offset);

                state.round_data_offset = offset + 0x8;
                offset += 0x8 + 0x20 * basic_marshalling.get_length(blob, offset);
                offset += 0x8;

                state.initial_proof_offset = offset;
                for (uint8 i = 0; i < lambda;) {
                    for (uint256 j = 0; j < batches_num;) {
                        if (basic_marshalling.get_uint256_be(blob, offset + 0x10) != commitments[j]) return false;
                        offset = merkle_verifier.skip_merkle_proof_be(blob, offset);
                        j++;
                    }
                    i++;
                }
                offset += 0x8;
                state.round_proof_offset = offset;

                for (uint256 i = 0; i < lambda;) {
                    for (uint256 j = 0; j < r;) {
                        if (
                            basic_marshalling.get_uint256_be(blob, offset + 0x10)
                                != basic_marshalling.get_uint256_be(blob, state.roots_offset + j * 40 + 0x8)
                        ) return false;
                        offset = merkle_verifier.skip_merkle_proof_be(blob, offset);
                        j++;
                    }
                    i++;
                }

                state.final_polynomial = new uint256[](basic_marshalling.get_length(blob, offset));
                offset += 0x8;
                for (uint256 i = 0; i < state.final_polynomial.length;) {
                    state.final_polynomial[i] = basic_marshalling.get_uint256_be(blob, offset);
                    i++;
                    offset += 0x20;
                }
            }
            if (state.final_polynomial.length > ((1 << (field.log2(max_degree + 1) - r + 1)))) {
                console.log("Wrong final poly degree");
                return false;
            }

            if (!prepare_U_V(blob, state, challenge)) return false;

            state.leaf_data = new bytes(state.max_batch * 0x40 + 0x40);
            for (uint256 i = 0; i < lambda;) {
                // Initial proofs
                state.x_index = uint256(transcript.get_integral_challenge_be(tr_state, 8)) % D0_size;
                state.x = field.pow_small(D0_omega, state.x_index, modulus);
                state.domain_size = D0_size >> 1;
                for (uint256 j = 0; j < batches_num;) {
                    if (state.x_index < state.domain_size) {
                        if (
                            !copy_pairs_and_check(
                                blob,
                                state.initial_data_offset,
                                state.leaf_data,
                                state.batch_sizes[j],
                                state.initial_proof_offset
                            )
                        ) {
                            console.log("Error in initial mekle proof");
                            return false;
                        }
                    } else {
                        if (
                            !copy_reverted_pairs_and_check(
                                blob,
                                state.initial_data_offset,
                                state.leaf_data,
                                state.batch_sizes[j],
                                state.initial_proof_offset
                            )
                        ) {
                            console.log("Error in initial mekle proof");
                            return false;
                        }
                    }
                    state.leaf_length = state.batch_sizes[j] * 0x40;
                    state.initial_data_offset += state.batch_sizes[j] * 0x40;
                    state.initial_proof_offset = merkle_verifier.skip_merkle_proof_be(blob, state.initial_proof_offset);
                    j++;
                }
                {
                    state.y = compute_combined_Q(blob, state);
                    if (state.x_index < state.domain_size) {
                        if (!copy_memory_pair_and_check(blob, state.round_proof_offset, state.leaf_data, state.y)) {
                            console.log("Not validated!");
                            return false;
                        }
                    } else {
                        if (
                            !copy_reverted_memory_pair_and_check(
                                blob, state.round_proof_offset, state.leaf_data, state.y
                            )
                        ) {
                            console.log("Not validated!");
                            return false;
                        }
                    }
                }
                if (
                    !colinear_check(
                        state.x,
                        state.y,
                        state.alphas[0],
                        basic_marshalling.get_uint256_be(blob, state.round_data_offset)
                    )
                ) {
                    console.log("Colinear check failed");
                    return false;
                }

                state.round_proof_offset = merkle_verifier.skip_merkle_proof_be(blob, state.round_proof_offset);
                for (state.j = 1; state.j < r;) {
                    state.x_index %= state.domain_size;
                    state.x = mulmod(state.x, state.x, modulus);
                    state.domain_size >>= 1;
                    if (state.x_index < state.domain_size) {
                        if (
                            !copy_pairs_and_check(
                                blob, state.round_data_offset, state.leaf_data, 1, state.round_proof_offset
                            )
                        ) {
                            console.log("Error in round mekle proof");
                            return false;
                        }
                    } else {
                        if (
                            !copy_reverted_pairs_and_check(
                                blob, state.round_data_offset, state.leaf_data, 1, state.round_proof_offset
                            )
                        ) {
                            console.log("Error in round mekle proof");
                            return false;
                        }
                    }
                    state.y[0] = basic_marshalling.get_uint256_be(blob, state.round_data_offset);
                    state.y[1] = basic_marshalling.get_uint256_be(blob, state.round_data_offset + 0x20);
                    if (
                        !colinear_check(
                            state.x,
                            state.y,
                            state.alphas[state.j],
                            basic_marshalling.get_uint256_be(blob, state.round_data_offset + 0x40)
                        )
                    ) {
                        console.log("Round colinear check failed");
                        return false;
                    }
                    state.j++;
                    state.round_data_offset += 0x40;
                    state.round_proof_offset = merkle_verifier.skip_merkle_proof_be(blob, state.round_proof_offset);
                }

                state.x = mulmod(state.x, state.x, modulus);
                if (
                    polynomial.evaluate(state.final_polynomial, state.x, modulus)
                        != basic_marshalling.get_uint256_be(blob, state.round_data_offset)
                ) {
                    console.log("Wrong final poly check");
                    return false;
                }
                if (
                    polynomial.evaluate(state.final_polynomial, modulus - state.x, modulus)
                        != basic_marshalling.get_uint256_be(blob, state.round_data_offset + 0x20)
                ) {
                    console.log("Wrong final poly check");
                    return false;
                }
                state.round_data_offset += 0x40;

                i++;
            }
            return true;
        }
    }
}
